/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the ranking order of results.
 */
export const AppBskyFeedSearchPostsSort = {
  Top: "top",
  Latest: "latest",
} as const;
/**
 * Specifies the ranking order of results.
 */
export type AppBskyFeedSearchPostsSort = ClosedEnum<
  typeof AppBskyFeedSearchPostsSort
>;

export type AppBskyFeedSearchPostsRequest = {
  /**
   * Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended.
   */
  q: string;
  /**
   * Specifies the ranking order of results.
   */
  sort?: AppBskyFeedSearchPostsSort | undefined;
  /**
   * Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD).
   */
  since?: string | undefined;
  /**
   * Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD).
   */
  until?: string | undefined;
  /**
   * Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions.
   */
  mentions?: string | undefined;
  /**
   * Filter to posts by the given account. Handles are resolved to DID before query-time.
   */
  author?: string | undefined;
  /**
   * Filter to posts in the given language. Expected to be based on post language field, though server may override language detection.
   */
  lang?: string | undefined;
  /**
   * Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization.
   */
  domain?: string | undefined;
  /**
   * Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching.
   */
  url?: string | undefined;
  /**
   * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
   */
  tag?: Array<string> | undefined;
  limit?: number | undefined;
  /**
   * Optional pagination mechanism; may not necessarily allow scrolling through entire result set.
   */
  cursor?: string | undefined;
};

/**
 * OK
 */
export type AppBskyFeedSearchPostsResponseBody = {
  cursor?: string | undefined;
  hitsTotal?: number | undefined;
  posts: Array<components.AppBskyFeedDefsPostView>;
};

export type AppBskyFeedSearchPostsResponse = {
  result: AppBskyFeedSearchPostsResponseBody;
};

/** @internal */
export const AppBskyFeedSearchPostsSort$inboundSchema: z.ZodNativeEnum<
  typeof AppBskyFeedSearchPostsSort
> = z.nativeEnum(AppBskyFeedSearchPostsSort);
/** @internal */
export const AppBskyFeedSearchPostsSort$outboundSchema: z.ZodNativeEnum<
  typeof AppBskyFeedSearchPostsSort
> = AppBskyFeedSearchPostsSort$inboundSchema;

/** @internal */
export const AppBskyFeedSearchPostsRequest$inboundSchema: z.ZodType<
  AppBskyFeedSearchPostsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  q: z.string(),
  sort: AppBskyFeedSearchPostsSort$inboundSchema.default("latest"),
  since: z.string().optional(),
  until: z.string().optional(),
  mentions: z.string().optional(),
  author: z.string().optional(),
  lang: z.string().optional(),
  domain: z.string().optional(),
  url: z.string().optional(),
  tag: z.array(z.string()).optional(),
  limit: z.number().int().default(25),
  cursor: z.string().optional(),
});
/** @internal */
export type AppBskyFeedSearchPostsRequest$Outbound = {
  q: string;
  sort: string;
  since?: string | undefined;
  until?: string | undefined;
  mentions?: string | undefined;
  author?: string | undefined;
  lang?: string | undefined;
  domain?: string | undefined;
  url?: string | undefined;
  tag?: Array<string> | undefined;
  limit: number;
  cursor?: string | undefined;
};

/** @internal */
export const AppBskyFeedSearchPostsRequest$outboundSchema: z.ZodType<
  AppBskyFeedSearchPostsRequest$Outbound,
  z.ZodTypeDef,
  AppBskyFeedSearchPostsRequest
> = z.object({
  q: z.string(),
  sort: AppBskyFeedSearchPostsSort$outboundSchema.default("latest"),
  since: z.string().optional(),
  until: z.string().optional(),
  mentions: z.string().optional(),
  author: z.string().optional(),
  lang: z.string().optional(),
  domain: z.string().optional(),
  url: z.string().optional(),
  tag: z.array(z.string()).optional(),
  limit: z.number().int().default(25),
  cursor: z.string().optional(),
});

export function appBskyFeedSearchPostsRequestToJSON(
  appBskyFeedSearchPostsRequest: AppBskyFeedSearchPostsRequest,
): string {
  return JSON.stringify(
    AppBskyFeedSearchPostsRequest$outboundSchema.parse(
      appBskyFeedSearchPostsRequest,
    ),
  );
}
export function appBskyFeedSearchPostsRequestFromJSON(
  jsonString: string,
): SafeParseResult<AppBskyFeedSearchPostsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AppBskyFeedSearchPostsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AppBskyFeedSearchPostsRequest' from JSON`,
  );
}

/** @internal */
export const AppBskyFeedSearchPostsResponseBody$inboundSchema: z.ZodType<
  AppBskyFeedSearchPostsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  cursor: z.string().optional(),
  hitsTotal: z.number().int().optional(),
  posts: z.array(components.AppBskyFeedDefsPostView$inboundSchema),
});
/** @internal */
export type AppBskyFeedSearchPostsResponseBody$Outbound = {
  cursor?: string | undefined;
  hitsTotal?: number | undefined;
  posts: Array<components.AppBskyFeedDefsPostView$Outbound>;
};

/** @internal */
export const AppBskyFeedSearchPostsResponseBody$outboundSchema: z.ZodType<
  AppBskyFeedSearchPostsResponseBody$Outbound,
  z.ZodTypeDef,
  AppBskyFeedSearchPostsResponseBody
> = z.object({
  cursor: z.string().optional(),
  hitsTotal: z.number().int().optional(),
  posts: z.array(components.AppBskyFeedDefsPostView$outboundSchema),
});

export function appBskyFeedSearchPostsResponseBodyToJSON(
  appBskyFeedSearchPostsResponseBody: AppBskyFeedSearchPostsResponseBody,
): string {
  return JSON.stringify(
    AppBskyFeedSearchPostsResponseBody$outboundSchema.parse(
      appBskyFeedSearchPostsResponseBody,
    ),
  );
}
export function appBskyFeedSearchPostsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<AppBskyFeedSearchPostsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AppBskyFeedSearchPostsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AppBskyFeedSearchPostsResponseBody' from JSON`,
  );
}

/** @internal */
export const AppBskyFeedSearchPostsResponse$inboundSchema: z.ZodType<
  AppBskyFeedSearchPostsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  Result: z.lazy(() => AppBskyFeedSearchPostsResponseBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "Result": "result",
  });
});
/** @internal */
export type AppBskyFeedSearchPostsResponse$Outbound = {
  Result: AppBskyFeedSearchPostsResponseBody$Outbound;
};

/** @internal */
export const AppBskyFeedSearchPostsResponse$outboundSchema: z.ZodType<
  AppBskyFeedSearchPostsResponse$Outbound,
  z.ZodTypeDef,
  AppBskyFeedSearchPostsResponse
> = z.object({
  result: z.lazy(() => AppBskyFeedSearchPostsResponseBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    result: "Result",
  });
});

export function appBskyFeedSearchPostsResponseToJSON(
  appBskyFeedSearchPostsResponse: AppBskyFeedSearchPostsResponse,
): string {
  return JSON.stringify(
    AppBskyFeedSearchPostsResponse$outboundSchema.parse(
      appBskyFeedSearchPostsResponse,
    ),
  );
}
export function appBskyFeedSearchPostsResponseFromJSON(
  jsonString: string,
): SafeParseResult<AppBskyFeedSearchPostsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AppBskyFeedSearchPostsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AppBskyFeedSearchPostsResponse' from JSON`,
  );
}
